<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <title>üõ°Ô∏è Advanced Exam Security System v2.0</title>

  <meta http-equiv="Content-Security-Policy" content="
    default-src 'none';
    script-src 'nonce-ultrasecure2024' 'unsafe-eval';
    style-src 'self' 'unsafe-inline';
    frame-src 'none';
    connect-src 'self' ws: wss:;
    base-uri 'none';
    object-src 'none';
    img-src 'self' data:;
    font-src 'self';
  ">

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
      color: #ffffff;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .header {
      text-align: center;
      border-bottom: 2px solid #ff4444;
      padding-bottom: 20px;
      margin-bottom: 30px;
    }
    
    .security-status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(255, 68, 68, 0.9);
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      max-width: 200px;
      z-index: 999999;
    }
    
    .question-container {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 12px;
      padding: 30px;
      margin: 20px auto;
      max-width: 800px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }
    
    .timer {
      font-size: 24px;
      font-weight: bold;
      color: #ff6b6b;
      text-align: center;
      margin: 20px 0;
      background: rgba(255, 107, 107, 0.1);
      padding: 15px;
      border-radius: 8px;
    }
    
    textarea {
      width: 100%;
      height: 120px;
      background: #222;
      color: white;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-size: 16px;
      resize: vertical;
      margin: 15px 0;
    }
    
    textarea:focus {
      border-color: #4CAF50;
      outline: none;
    }
    
    .option {
      background: rgba(255, 255, 255, 0.05);
      margin: 10px 0;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .option:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: #4CAF50;
    }
    
    .option input[type="radio"] {
      margin-right: 10px;
      transform: scale(1.2);
    }
    
    button {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 8px;
      cursor: pointer;
      display: block;
      margin: 30px auto;
      transition: all 0.3s ease;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
    }
    
    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }
    
    .log-container {
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin-top: 30px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .log-entry {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      margin: 2px 0;
      padding: 2px 5px;
      border-radius: 3px;
    }
    
    .log-warning { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
    .log-error { background: rgba(255, 69, 58, 0.2); color: #ff453a; }
    .log-info { background: rgba(0, 122, 255, 0.2); color: #007aff; }
    .log-success { background: rgba(52, 199, 89, 0.2); color: #34c759; }
    
    .threat-level {
      position: fixed;
      top: 60px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 11px;
      font-weight: bold;
    }
    
    .threat-low { background: #4CAF50; }
    .threat-medium { background: #ff9800; }
    .threat-high { background: #f44336; }
    .threat-critical { background: #9c27b0; animation: pulse 1s infinite; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .webcam-indicator {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 20px;
      height: 20px;
      background: #f44336;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
  </style>
</head>
<body>
  <div class="webcam-indicator" title="Camera monitoring active"></div>
  
  <div class="security-status" id="securityStatus">
    üõ°Ô∏è Security: ACTIVE<br>
    üé• Proctoring: ON<br>
    üì° Monitoring: LIVE
  </div>
  
  <div class="threat-level threat-low" id="threatLevel">THREAT: LOW</div>
  
  <div class="header">
    <h1>üõ°Ô∏è Advanced Proctored Exam</h1>
    <p>‚ö†Ô∏è This exam is under continuous surveillance. Any suspicious activity will be logged and reported.</p>
  </div>

  <div class="question-container">
    <div id="question"></div>
    <div class="timer" id="timer">Timp rƒÉmas: <span id="sec">60</span> secunde</div>
    <button id="submit">üì§ Trimite RƒÉspuns Final</button>
  </div>

  <div class="log-container">
    <h3>üîç Security Event Log (Real-time)</h3>
    <div id="log"></div>
  </div>

  <script nonce="ultrasecure2024">
    // ‚≠ê ADVANCED ANTI-CHEATING SYSTEM v2.0
    
    const securityStatus = document.getElementById("securityStatus");
    const threatLevel = document.getElementById("threatLevel");
    const logContainer = document.getElementById("log");
    
    let threatScore = 0;
    let violations = [];
    let examStartTime = Date.now();
    let keystrokePatterns = [];
    let mouseMovements = [];
    let suspiciousEvents = 0;
    
    // ‚≠ê EXAM QUESTIONS
    const questions = [
      {type: "text", question: "Ce face event.preventDefault() √Æn JavaScript?"},
      {type: "mcq", question: "Care din urmƒÉtoarele este o metodƒÉ validƒÉ pentru selectarea unui element HTML?", 
       options: ["document.querySelector()", "document.getElement()", "document.findElement()", "document.selectElement()"]},
      {type: "text", question: "ExplicƒÉ diferen»õa dintre var, let »ôi const √Æn JavaScript:"},
      {type: "mcq", question: "Ce returneazƒÉ typeof null √Æn JavaScript?", 
       options: ["null", "undefined", "object", "boolean"]},
      {type: "text", question: "Cum adaugi un event listener pentru click pe un element?"},
      {type: "mcq", question: "Care atribut HTML define»ôte destina»õia unui link?", 
       options: ["src", "href", "link", "destination"]},
      {type: "text", question: "Ce este DOM-ul »ôi cum interac»õionezi cu el √Æn JavaScript?"},
      {type: "mcq", question: "Ce selecteazƒÉ querySelector('.box p')?", 
       options: ["Toate elementele cu clasa box", "Toate paragrafele", "Primul paragraf din primul .box", "Ultimul paragraf"]},
    ];

    const currentQuestion = questions[Math.floor(Math.random() * questions.length)];
    let selectedAnswer = "";
    let examActive = true;

    // ‚≠ê RENDER QUESTION
    function renderQuestion(q) {
      let html = `<h2>‚ùì ${q.question}</h2>`;
      if (q.type === "text") {
        html += `<textarea id="answer" placeholder="Scrie rƒÉspunsul aici..."></textarea>`;
      } else {
        q.options.forEach((opt, idx) => {
          html += `<div class="option" onclick="selectOption('${opt}')">
            <input type="radio" name="opt" value="${opt}" id="opt${idx}"> 
            <label for="opt${idx}">${opt}</label>
          </div>`;
        });
      }
      document.getElementById("question").innerHTML = html;
    }

    function selectOption(value) {
      selectedAnswer = value;
      document.querySelectorAll('.option').forEach(opt => opt.style.borderColor = 'transparent');
      event.target.closest('.option').style.borderColor = '#4CAF50';
      logSecurityEvent('üìù Option selected', 'info');
    }

    renderQuestion(currentQuestion);

    // ‚≠ê TIMER SYSTEM
    let timeLeft = 60;
    const timerEl = document.getElementById("sec");
    
    const countdown = setInterval(() => {
      timeLeft--;
      timerEl.textContent = timeLeft;
      
      if (timeLeft <= 10) {
        timerEl.parentElement.style.background = 'rgba(255, 69, 58, 0.3)';
        timerEl.parentElement.style.animation = 'pulse 1s infinite';
      }
      
      if (timeLeft === 0) {
        clearInterval(countdown);
        handleSubmit(true);
      }
    }, 1000);

    // ‚≠ê SUBMIT HANDLER
    document.getElementById("submit").onclick = () => {
      clearInterval(countdown);
      handleSubmit(false);
    };

    function handleSubmit(auto) {
      examActive = false;
      let answer = "";
      
      if (currentQuestion.type === "text") {
        answer = document.getElementById("answer")?.value.trim() || "FƒÉrƒÉ rƒÉspuns";
      } else {
        const checked = document.querySelector('input[name="opt"]:checked');
        answer = checked ? checked.value : selectedAnswer || "Nimic selectat";
      }

      const examDuration = ((Date.now() - examStartTime) / 1000).toFixed(1);
      
      logSecurityEvent(auto 
        ? `‚è±Ô∏è Examen finalizat automat (${examDuration}s): ${answer}` 
        : `‚úÖ Examen trimis manual (${examDuration}s): ${answer}`, 'success');
      
      document.getElementById("submit").disabled = true;
      
      // Generate final security report
      generateSecurityReport();
    }

    // ‚≠ê ADVANCED SECURITY MONITORING

    // 1. Extension Detection (Multiple Methods)
    function detectExtensions() {
      const detectionMethods = [];
      
      // Method 1: Chrome Runtime
      if (window.chrome && window.chrome.runtime) {
        detectionMethods.push("chrome.runtime detected");
        increaseThreat(20);
      }
      
      // Method 2: Extension Resource Detection
      const testImg = new Image();
      testImg.onload = () => {
        detectionMethods.push("Extension resource accessible");
        increaseThreat(15);
      };
      testImg.src = 'chrome-extension://invalid/test.png';
      
      // Method 3: DOM Modification Detection
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === 1) {
                const suspicious = node.id?.includes('stealth') || 
                                 node.className?.includes('stealth') ||
                                 node.style?.zIndex > 2147483640;
                
                if (suspicious) {
                  logSecurityEvent(`üö® Suspicious DOM element added: ${node.tagName}#${node.id}`, 'error');
                  increaseThreat(25);
                }
              }
            });
          }
        });
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'class', 'id']
      });
      
      // Method 4: Shadow DOM Detection
      const originalAttachShadow = Element.prototype.attachShadow;
      Element.prototype.attachShadow = function(...args) {
        logSecurityEvent('üö® Shadow DOM creation detected!', 'error');
        increaseThreat(30);
        return originalAttachShadow.apply(this, args);
      };
      
      if (detectionMethods.length > 0) {
        logSecurityEvent(`üß© Extension detected: ${detectionMethods.join(', ')}`, 'error');
      }
    }

    // 2. Network Request Monitoring
    function monitorNetworkRequests() {
      const originalFetch = window.fetch;
      window.fetch = function (...args) {
        const url = args[0];
        if (typeof url === 'string') {
          if (url.includes('localhost') || url.includes('127.0.0.1') || 
              url.includes('openai') || url.includes('api') ||
              url.match(/:\d{4,5}/)) {
            logSecurityEvent(`üîç Suspicious fetch to: ${url}`, 'error');
            increaseThreat(35);
          }
        }
        return originalFetch.apply(this, args);
      };

      const originalXHR = window.XMLHttpRequest;
      window.XMLHttpRequest = function () {
        const xhr = new originalXHR();
        const originalOpen = xhr.open;
        xhr.open = function(method, url) {
          if (typeof url === 'string' && 
              (url.includes('localhost') || url.includes('127.0.0.1') || 
               url.includes('api') || url.match(/:\d{4,5}/))) {
            logSecurityEvent(`üîç Suspicious XHR to: ${url}`, 'error');
            increaseThreat(35);
          }
          return originalOpen.apply(this, arguments);
        };
        return xhr;
      };
    }

    // 3. Advanced DevTools Detection
    function detectDevTools() {
      // Method 1: Console log redirection
      const devtools = /./;
      devtools.toString = function () {
        logSecurityEvent("üö® DevTools opened (console detection)!", 'error');
        increaseThreat(40);
      };
      console.log("%c", devtools);
      
      // Method 2: Timing-based detection
      let start = performance.now();
      debugger;
      let end = performance.now();
      if (end - start > 100) {
        logSecurityEvent("üö® DevTools opened (debugger timing)!", 'error');
        increaseThreat(40);
      }
      
      // Method 3: Screen size detection
      const threshold = 160;
      setInterval(() => {
        if (window.outerHeight - window.innerHeight > threshold || 
            window.outerWidth - window.innerWidth > threshold) {
          logSecurityEvent("üö® DevTools possibly opened (size detection)!", 'warning');
          increaseThreat(15);
        }
      }, 3000);
      
      // Method 4: Performance timing
      setInterval(() => {
        const start = performance.now();
        console.clear();
        const end = performance.now();
        if (end - start > 5) {
          logSecurityEvent("üö® DevTools detected (performance timing)!", 'error');
          increaseThreat(30);
        }
      }, 5000);
    }

    // 4. Tab/Window Focus Monitoring
    function monitorFocus() {
      let tabSwitches = 0;
      let focusLost = 0;
      
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          tabSwitches++;
          logSecurityEvent(`üö® Tab switched/hidden (${tabSwitches} times)`, 'error');
          increaseThreat(25);
        } else {
          logSecurityEvent("‚úîÔ∏è Tab active again", 'info');
        }
      });
      
      window.addEventListener("blur", () => {
        focusLost++;
        logSecurityEvent(`üö® Window focus lost (${focusLost} times)`, 'warning');
        increaseThreat(10);
      });
      
      window.addEventListener("focus", () => {
        logSecurityEvent("‚úîÔ∏è Window focus restored", 'info');
      });
    }

    // 5. Keystroke Pattern Analysis
    function analyzeKeystrokePatterns() {
      let lastKeyTime = 0;
      let typingIntervals = [];
      
      document.addEventListener("keydown", (e) => {
        const currentTime = Date.now();
        if (lastKeyTime > 0) {
          const interval = currentTime - lastKeyTime;
          typingIntervals.push(interval);
          
          // Detect unusually fast typing (possible paste)
          if (interval < 50 && typingIntervals.length > 5) {
            logSecurityEvent("‚ö° Unusually fast typing detected (possible paste)", 'warning');
            increaseThreat(15);
          }
          
          // Detect copy-paste patterns
          if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) {
            logSecurityEvent("üìã Paste operation detected", 'warning');
            increaseThreat(20);
          }
        }
        lastKeyTime = currentTime;
        
        // Store keystroke patterns
        keystrokePatterns.push({
          key: e.key,
          timestamp: currentTime,
          interval: currentTime - lastKeyTime
        });
      });
    }

    // 6. Mouse Movement Analysis
    function analyzeMouseMovements() {
      let lastMouseMove = 0;
      let mousePoints = [];
      
      document.addEventListener("mousemove", (e) => {
        const currentTime = Date.now();
        mousePoints.push({
          x: e.clientX,
          y: e.clientY,
          timestamp: currentTime
        });
        
        // Keep only last 50 points for analysis
        if (mousePoints.length > 50) {
          mousePoints.shift();
        }
        
        // Detect unnatural mouse movements
        if (mousePoints.length > 10) {
          const movements = mousePoints.slice(-10);
          const isLinear = movements.every((point, index) => {
            if (index === 0) return true;
            const prev = movements[index - 1];
            const deltaX = Math.abs(point.x - prev.x);
            const deltaY = Math.abs(point.y - prev.y);
            return deltaX < 5 && deltaY < 5; // Too perfect movements
          });
          
          if (isLinear) {
            logSecurityEvent("ü§ñ Unnatural mouse movement detected", 'warning');
            increaseThreat(10);
          }
        }
        
        lastMouseMove = currentTime;
      });
      
      // Detect inactivity
      setInterval(() => {
        if (Date.now() - lastMouseMove > 30000 && examActive) {
          logSecurityEvent("‚ö†Ô∏è Extended inactivity detected!", 'warning');
          increaseThreat(5);
        }
      }, 10000);
    }

    // 7. Memory Usage Monitoring
    function monitorMemoryUsage() {
      if (performance.memory) {
        const initialMemory = performance.memory.usedJSHeapSize;
        
        setInterval(() => {
          const currentMemory = performance.memory.usedJSHeapSize;
          const memoryIncrease = currentMemory - initialMemory;
          
          if (memoryIncrease > 10 * 1024 * 1024) { // 10MB increase
            logSecurityEvent(`üíæ Significant memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB`, 'warning');
            increaseThreat(15);
          }
          
          const memoryMB = (currentMemory / 1024 / 1024).toFixed(2);
          logSecurityEvent(`üíæ Memory usage: ${memoryMB}MB`, 'info');
        }, 15000);
      }
    }

    // 8. Right-click and Keyboard Shortcuts
    function blockSuspiciousActions() {
      document.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        logSecurityEvent("üö´ Right-click blocked", 'warning');
        increaseThreat(5);
      });
      
      document.addEventListener("keydown", (e) => {
        // Block common developer shortcuts
        const blockedCombos = [
          { ctrl: true, key: 'u' },         // View source
          { ctrl: true, shift: true, key: 'i' }, // DevTools
          { ctrl: true, shift: true, key: 'j' }, // Console
          { ctrl: true, shift: true, key: 'c' }, // Element inspector
          { key: 'F12' },                   // DevTools
          { ctrl: true, key: 'r' },         // Refresh
          { ctrl: true, shift: true, key: 'r' }, // Hard refresh
          { ctrl: true, key: 'w' },         // Close tab
          { ctrl: true, key: 't' },         // New tab
          { alt: true, key: 'Tab' },        // Alt-Tab
        ];
        
        const isBlocked = blockedCombos.some(combo => {
          return (!combo.ctrl || e.ctrlKey) &&
                 (!combo.shift || e.shiftKey) &&
                 (!combo.alt || e.altKey) &&
                 (e.key === combo.key || e.code === combo.key);
        });
        
        if (isBlocked) {
          e.preventDefault();
          logSecurityEvent(`üö´ Blocked shortcut: ${e.ctrlKey ? 'Ctrl+' : ''}${e.shiftKey ? 'Shift+' : ''}${e.altKey ? 'Alt+' : ''}${e.key}`, 'warning');
          increaseThreat(20);
        }
      });
    }

    // ‚≠ê THREAT MANAGEMENT
    function increaseThreat(points) {
      threatScore += points;
      suspiciousEvents++;
      updateThreatLevel();
      
      if (threatScore > 100) {
        logSecurityEvent("üö® CRITICAL THREAT LEVEL REACHED - EXAM MAY BE TERMINATED", 'error');
        // In a real system, this would terminate the exam
      }
    }

    function updateThreatLevel() {
      let level, className, text;
      
      if (threatScore < 25) {
        level = "LOW";
        className = "threat-low";
      } else if (threatScore < 50) {
        level = "MEDIUM";
        className = "threat-medium";
      } else if (threatScore < 100) {
        level = "HIGH";
        className = "threat-high";
      } else {
        level = "CRITICAL";
        className = "threat-critical";
      }
      
      threatLevel.textContent = `THREAT: ${level} (${threatScore})`;
      threatLevel.className = `threat-level ${className}`;
    }

    // ‚≠ê LOGGING SYSTEM
    function logSecurityEvent(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.textContent = `[${timestamp}] ${message}`;
      
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
      
      // Store for final report
      violations.push({
        timestamp: Date.now(),
        message,
        type,
        threatScore
      });
      
      console.log(`[SECURITY] ${message}`);
    }

    // ‚≠ê FINAL SECURITY REPORT
    function generateSecurityReport() {
      const examDuration = ((Date.now() - examStartTime) / 1000).toFixed(1);
      const report = {
        examDuration,
        finalThreatScore: threatScore,
        totalViolations: violations.length,
        suspiciousEvents,
        violations: violations,
        keystrokeData: keystrokePatterns.length,
        mouseData: mouseMovements.length
      };
      
      logSecurityEvent("üìã Generating final security report...", 'info');
      logSecurityEvent(`üìä Final Score: ${threatScore}/100 | Events: ${suspiciousEvents} | Duration: ${examDuration}s`, 'info');
      
      // In a real system, this would be sent to the server
      console.log("FINAL SECURITY REPORT:", report);
    }

    // ‚≠ê INITIALIZE ALL SECURITY SYSTEMS
    function initializeSecurity() {
      logSecurityEvent("üõ°Ô∏è Security systems initializing...", 'info');
      
      detectExtensions();
      monitorNetworkRequests();
      detectDevTools();
      monitorFocus();
      analyzeKeystrokePatterns();
      analyzeMouseMovements();
      monitorMemoryUsage();
      blockSuspiciousActions();
      
      logSecurityEvent("‚úÖ All security systems active", 'success');
      
      // Periodic security checks
      setInterval(() => {
        if (examActive) {
          detectExtensions();
          logSecurityEvent(`üîÑ Periodic security scan complete (Score: ${threatScore})`, 'info');
        }
      }, 10000);
    }

    // ‚≠ê START SECURITY MONITORING
    initializeSecurity();
    
    // ‚≠ê PREVENT EXAM MANIPULATION
    window.addEventListener('beforeunload', (e) => {
      if (examActive) {
        const message = 'Leaving the exam page will be recorded as a violation!';
        e.returnValue = message;
        logSecurityEvent("‚ö†Ô∏è User attempted to leave exam page", 'warning');
        increaseThreat(50);
        return message;
      }
    });
    
  </script>
</body>
</html>